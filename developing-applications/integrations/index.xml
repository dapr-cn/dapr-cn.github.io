<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dapr 文档库 – 集成</title><link>https://docs.dapr.io/developing-applications/integrations/</link><description>Recent content in 集成 on Dapr 文档库</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://docs.dapr.io/developing-applications/integrations/index.xml" rel="self" type="application/rss+xml"/><item><title>Developing-Applications: Dapr的gRPC接口</title><link>https://docs.dapr.io/developing-applications/integrations/grpc-integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.dapr.io/developing-applications/integrations/grpc-integration/</guid><description>
&lt;h1 id="dapr-和-grpc">Dapr 和 gRPC&lt;/h1>
&lt;p>Dapr 为本地调用实现 HTTP 和 gRPC API 。 gRPC适用于低延迟、高性能的场景，并且使用原生客户端进行语言集成。&lt;/p>
&lt;p>您可以在 &lt;a href="https://github.com/dapr/docs#sdks">这里&lt;/a>找到自动生成的客户端 的列表。&lt;/p>
&lt;p>Dapr 运行时实现 &lt;a href="https://github.com/dapr/dapr/blob/master/dapr/proto/runtime/v1/dapr.proto">proto服务&lt;/a> ，应用程序可以通过 gRPC 进行通信。&lt;/p>
&lt;p>除了通过 gRPC 调用 Dapr ， Dapr 也可以通过 gRPC 与应用程序通信。 要做到这一点，应用程序需要托管一个gRPC服务器，并实现&lt;a href="https://github.com/dapr/dapr/blob/master/dapr/proto/runtime/v1/appcallback.proto">Dapr appcallback服务&lt;/a>。&lt;/p>
&lt;h2 id="dapr-通过-grpc-与应用程序通信的配置">Dapr 通过 gRPC 与应用程序通信的配置&lt;/h2>
&lt;h3 id="自托管">自托管&lt;/h3>
&lt;p>在自托管模式下运行时，使用 &lt;code>--app-protocol&lt;/code> 标志来配置Dapr 使用 gRPC 与应用程序通信：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">dapr run --app-protocol grpc --app-port &lt;span style="color:#ae81ff">5005&lt;/span> node app.js
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这将告诉Dapr通过gRPC与您的应用程序通过&lt;code>5005&lt;/code>端口进行通信。&lt;/p>
&lt;h3 id="kubernetes">Kubernetes&lt;/h3>
&lt;p>在Kubernetes中，需要在deployment YAML文件中设置以下注解:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">apps/v1&lt;/span>
&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Deployment&lt;/span>
&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;span style="color:#f92672">labels&lt;/span>:
&lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;span style="color:#f92672">spec&lt;/span>:
&lt;span style="color:#f92672">replicas&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#f92672">selector&lt;/span>:
&lt;span style="color:#f92672">matchLabels&lt;/span>:
&lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;span style="color:#f92672">template&lt;/span>:
&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;span style="color:#f92672">labels&lt;/span>:
&lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">myapp&lt;/span>
&lt;span style="color:#f92672">annotations&lt;/span>:
&lt;span style="color:#f92672">dapr.io/enabled&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>
&lt;span style="color:#f92672">dapr.io/app-id&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;myapp&amp;#34;&lt;/span>
&lt;span style="color:#f92672">dapr.io/app-protocol&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;grpc&amp;#34;&lt;/span>
&lt;span style="color:#f92672">dapr.io/app-port&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;5005&amp;#34;&lt;/span>
...
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用-grpc-调用-dapr---go语言示例">使用 gRPC 调用 Dapr - Go语言示例&lt;/h2>
&lt;p>下面的步骤显示了如何创建 Dapr 客户端并调用 &lt;code>SaveStateData&lt;/code> 操作：&lt;/p>
&lt;ol>
&lt;li>导入包&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;context&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;log&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;os&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">dapr&lt;/span> &lt;span style="color:#e6db74">&amp;#34;github.com/dapr/go-sdk/client&amp;#34;&lt;/span>
)
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>创建客户端&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">//仅为本示例
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Background&lt;/span>()
&lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []byte(&lt;span style="color:#e6db74">&amp;#34;ping&amp;#34;&lt;/span>)
&lt;span style="color:#75715e">// 创建客户端
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">client&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">dapr&lt;/span>.&lt;span style="color:#a6e22e">NewClient&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Panic&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>)
}
&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>调用 &amp;quot; SaveState &amp;quot; 方法&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// 保存key1的状态
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">err&lt;/span> = &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">SaveState&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;statestore&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;key1&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">data&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Panic&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>)
}
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;data saved&amp;#34;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>好耶!&lt;/p>
&lt;p>现在你可以在Dapr客户端上探索各种各样的方法了。&lt;/p>
&lt;h2 id="使用-dapr-创建-grpc-应用程序">使用 Dapr 创建 gRPC 应用程序&lt;/h2>
&lt;p>以下步骤将向您显示如何创建一个让Dapr服务器与之通信的应用程序。&lt;/p>
&lt;ol>
&lt;li>导入包&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;context&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;log&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;net&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;github.com/golang/protobuf/ptypes/any&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;github.com/golang/protobuf/ptypes/empty&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">commonv1pb&lt;/span> &lt;span style="color:#e6db74">&amp;#34;github.com/dapr/go-sdk/dapr/proto/common/v1&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">pb&lt;/span> &lt;span style="color:#e6db74">&amp;#34;github.com/dapr/go-sdk/dapr/proto/runtime/v1&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;google.golang.org/grpc&amp;#34;&lt;/span>
)
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>实现接口&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// server is our user app
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">server&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">UnimplementedAppCallbackServer&lt;/span>
}
&lt;span style="color:#75715e">// EchoMethod is a simple demo method to invoke
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span>) &lt;span style="color:#a6e22e">EchoMethod&lt;/span>() &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;pong&amp;#34;&lt;/span>
}
&lt;span style="color:#75715e">// This method gets invoked when a remote service has called the app through Dapr
&lt;/span>&lt;span style="color:#75715e">// The payload carries a Method to identify the method, a set of metadata properties and an optional payload
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span>) &lt;span style="color:#a6e22e">OnInvoke&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">in&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">commonv1pb&lt;/span>.&lt;span style="color:#a6e22e">InvokeRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">commonv1pb&lt;/span>.&lt;span style="color:#a6e22e">InvokeResponse&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">response&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">in&lt;/span>.&lt;span style="color:#a6e22e">Method&lt;/span> {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;EchoMethod&amp;#34;&lt;/span>:
&lt;span style="color:#a6e22e">response&lt;/span> = &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">EchoMethod&lt;/span>()
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">commonv1pb&lt;/span>.&lt;span style="color:#a6e22e">InvokeResponse&lt;/span>{
&lt;span style="color:#a6e22e">ContentType&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;text/plain; charset=UTF-8&amp;#34;&lt;/span>,
&lt;span style="color:#a6e22e">Data&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">any&lt;/span>.&lt;span style="color:#a6e22e">Any&lt;/span>{&lt;span style="color:#a6e22e">Value&lt;/span>: []byte(&lt;span style="color:#a6e22e">response&lt;/span>)},
}, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#75715e">// Dapr will call this method to get the list of topics the app wants to subscribe to. In this example, we are telling Dapr
&lt;/span>&lt;span style="color:#75715e">// To subscribe to a topic named TopicA
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span>) &lt;span style="color:#a6e22e">ListTopicSubscriptions&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">in&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">empty&lt;/span>.&lt;span style="color:#a6e22e">Empty&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">ListTopicSubscriptionsResponse&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">ListTopicSubscriptionsResponse&lt;/span>{
&lt;span style="color:#a6e22e">Subscriptions&lt;/span>: []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">TopicSubscription&lt;/span>{
{&lt;span style="color:#a6e22e">Topic&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;TopicA&amp;#34;&lt;/span>},
},
}, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#75715e">// Dapr will call this method to get the list of bindings the app will get invoked by. In this example, we are telling Dapr
&lt;/span>&lt;span style="color:#75715e">// To invoke our app with a binding named storage
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span>) &lt;span style="color:#a6e22e">ListInputBindings&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">in&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">empty&lt;/span>.&lt;span style="color:#a6e22e">Empty&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">ListInputBindingsResponse&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">ListInputBindingsResponse&lt;/span>{
&lt;span style="color:#a6e22e">Bindings&lt;/span>: []&lt;span style="color:#66d9ef">string&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;storage&amp;#34;&lt;/span>},
}, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#75715e">// This method gets invoked every time a new event is fired from a registerd binding. The message carries the binding name, a payload and optional metadata
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span>) &lt;span style="color:#a6e22e">OnBindingEvent&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">in&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">BindingEventRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">BindingEventResponse&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Invoked from binding&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">BindingEventResponse&lt;/span>{}, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#75715e">// This method is fired whenever a message has been published to a topic that has been subscribed. Dapr sends published messages in a CloudEvents 0.3 envelope.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span>) &lt;span style="color:#a6e22e">OnTopicEvent&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">in&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">TopicEventRequest&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">TopicEventResponse&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Topic message arrived&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">TopicEventResponse&lt;/span>{}, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>创建服务器&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#75715e">// create listener
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">lis&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">net&lt;/span>.&lt;span style="color:#a6e22e">Listen&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;tcp&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;:50001&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to listen: %v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
}
&lt;span style="color:#75715e">// create grpc server
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">grpc&lt;/span>.&lt;span style="color:#a6e22e">NewServer&lt;/span>()
&lt;span style="color:#a6e22e">pb&lt;/span>.&lt;span style="color:#a6e22e">RegisterAppCallbackServer&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span>{})
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Client starting...&amp;#34;&lt;/span>)
&lt;span style="color:#75715e">// 启动......
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">Serve&lt;/span>(&lt;span style="color:#a6e22e">lis&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatalf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to serve: %v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这将在4000 端口上为应用程序创建一个 gRPC 服务器。&lt;/p>
&lt;ol start="4">
&lt;li>运行你的应用&lt;/li>
&lt;/ol>
&lt;p>使用 Dapr CLI在本地运行：&lt;/p>
&lt;pre>&lt;code>dapr run --app-id goapp --app-port 4000 --app-protocol grpc go run main.go
&lt;/code>&lt;/pre>&lt;p>Kubernetes 中，必须在您的Pod规范文档中进行如下设置： &lt;code>dapr.io/app-protocol: &amp;quot;grpc&amp;quot;&lt;/code> 和 &lt;code>dapr.io/app-port: &amp;quot; 4000&lt;/code> 。&lt;/p>
&lt;h2 id="其他语言">其他语言&lt;/h2>
&lt;p>您可以将 Dapr 与支持Protobuf 的任意语言一起使用，而不仅仅是当前已经生成可用的SDKs。 使用 &lt;a href="https://developers.google.com/protocol-buffers/docs/downloads">protoc&lt;/a> 工具，您可以为 Ruby， C++， Rust 等其他语言生成 Dapr 客户端。&lt;/p>
&lt;p>相关主题&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.dapr.io/developing-applications/building-blocks/service-invocation/">服务调用构建块&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.dapr.io/reference/api/service_invocation_api/">服务调用 API 规范&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Developing-Applications: 使用KEDA对Dapr应用进行自动缩放</title><link>https://docs.dapr.io/developing-applications/integrations/autoscale-keda/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.dapr.io/developing-applications/integrations/autoscale-keda/</guid><description>
&lt;p>Dapr, with its modular building-block approach, along with the 10+ different &lt;a href="https://docs.dapr.io/developing-applications/building-blocks/pubsub/">pub/sub components&lt;/a>, make it easy to write message processing applications. 由于Dapr可以在许多环境中运行（如虚拟机、裸机、云或边缘），因此Dapr应用的自动伸缩是由宿主管理的。&lt;/p>
&lt;p>对于Kubernetes，Dapr集成了&lt;a href="https://github.com/kedacore/keda">KEDA&lt;/a>，这是一个用于Kubernetes的事件驱动的自动伸缩组件。 Dapr的许多pub/sub组件与&lt;a href="https://github.com/kedacore/keda">KEDA&lt;/a>提供的扩展器重叠，因此很容易在Kubernetes上配置Dapr的deployment，以使用KEDA根据背压自动扩展。&lt;/p>
&lt;p>This how-to walks through the configuration of a scalable Dapr application along with the back pressure on Kafka topic, however you can apply this approach to any &lt;a href="https://docs.dapr.io/developing-applications/building-blocks/pubsub/">pub/sub components&lt;/a> offered by Dapr.&lt;/p>
&lt;h2 id="安装keda">安装KEDA&lt;/h2>
&lt;p>要安装KEDA，请遵循KEDA网站上的&lt;a href="https://keda.sh/docs/latest/deploy/">部署KEDA&lt;/a>说明。&lt;/p>
&lt;h2 id="安装kafka可选">安装Kafka(可选)&lt;/h2>
&lt;p>如果你没有Kafka，你可以通过使用Helm将其安装到你的Kubernetes集群中，见下面的示例:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">helm repo add confluentinc https://confluentinc.github.io/cp-helm-charts/
helm repo update
kubectl create ns kafka
helm install kafka confluentinc/cp-helm-charts -n kafka &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --set cp-schema-registry.enabled&lt;span style="color:#f92672">=&lt;/span>false &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --set cp-kafka-rest.enabled&lt;span style="color:#f92672">=&lt;/span>false &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --set cp-kafka-connect.enabled&lt;span style="color:#f92672">=&lt;/span>false
&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查Kafka部署的状态:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">kubectl rollout status deployment.apps/kafka-cp-control-center -n kafka
kubectl rollout status deployment.apps/kafka-cp-ksql-server -n kafka
kubectl rollout status statefulset.apps/kafka-cp-kafka -n kafka
kubectl rollout status statefulset.apps/kafka-cp-zookeeper -n kafka
&lt;/code>&lt;/pre>&lt;/div>&lt;p>完成后，还要部署Kafka客户端，并等待就绪:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">kubectl apply -n kafka -f deployment/kafka-client.yaml
kubectl wait -n kafka --for&lt;span style="color:#f92672">=&lt;/span>condition&lt;span style="color:#f92672">=&lt;/span>ready pod kafka-client --timeout&lt;span style="color:#f92672">=&lt;/span>120s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，创建本例中使用的主题(这里用&lt;code>demo-topic&lt;/code>为例):&lt;/p>
&lt;blockquote>
&lt;p>主题分区的数量与KEDA为你的deployment创建的最大副本数量有关。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">kubectl -n kafka exec -it kafka-client -- kafka-topics &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --zookeeper kafka-cp-zookeeper-headless:2181 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --topic demo-topic &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --create &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --partitions &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --replication-factor &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --if-not-exists
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="部署-dapr-pubsub-组件">部署 Dapr Pub/Sub 组件&lt;/h2>
&lt;p>接下来，我们将为Kubernetes部署Dapr Kafka pub/sub组件。 将以下YAML粘贴到一个名为&lt;code>kafka-pubsub.yaml&lt;/code>的文件中:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">dapr.io/v1alpha1&lt;/span>
&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Component&lt;/span>
&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">autoscaling-pubsub&lt;/span>
&lt;span style="color:#f92672">spec&lt;/span>:
&lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">pubsub.kafka&lt;/span>
&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;span style="color:#f92672">metadata&lt;/span>:
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">brokers&lt;/span>
&lt;span style="color:#f92672">value&lt;/span>: &lt;span style="color:#ae81ff">kafka-cp-kafka.kafka.svc.cluster.local:9092&lt;/span>
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">authRequired&lt;/span>
&lt;span style="color:#f92672">value&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;false&amp;#34;&lt;/span>
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">consumerID&lt;/span>
&lt;span style="color:#f92672">value&lt;/span>: &lt;span style="color:#ae81ff">autoscaling-subscriber&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的YAML定义了你的应用程序所订阅的pub/sub组件，也就是我们在上面创建的&lt;code>demo-topic&lt;/code>。 如果你使用了上面的Kafka Helm安装说明，你可以将&lt;code>brokers&lt;/code>值保持不变。 否则，将其改为你的Kafka broker的连接地址字符串。&lt;/p>
&lt;p>另外，请注意&lt;code>consumerID&lt;/code>的&lt;code>autoscaling-subscriber&lt;/code>值设置，该值稍后用于确保KEDA和你的deployment使用相同的 &lt;a href="http://cloudurable.com/blog/kafka-architecture-topics/index.html#:~:text=Kafka%20continually%20appended%20to%20partitions,fit%20on%20a%20single%20server.">Kafka分区偏移量&lt;/a>。&lt;/p>
&lt;p>现在，将该组件部署到集群中:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl apply -f kafka-pubsub.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="为kafka部署keda自动伸缩">为Kafka部署KEDA自动伸缩&lt;/h2>
&lt;p>接下来，我们将部署KEDA缩放对象，该对象可以监控指定Kafka主题上的延迟情况，并配置Kubernetes Horizontal Pod Autoscaler (HPA) 来缩放你的Dapr deployment。&lt;/p>
&lt;p>将以下内容粘贴到名为&lt;code>kafka_scaler.yaml&lt;/code>的文件中，并在需要的地方配置你的Dapr deployment。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">keda.sh/v1alpha1&lt;/span>
&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">ScaledObject&lt;/span>
&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">subscriber-scaler&lt;/span>
&lt;span style="color:#f92672">spec&lt;/span>:
&lt;span style="color:#f92672">scaleTargetRef&lt;/span>:
&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">&amp;lt;REPLACE-WITH-DAPR-DEPLOYMENT-NAME&amp;gt;&lt;/span>
&lt;span style="color:#f92672">pollingInterval&lt;/span>: &lt;span style="color:#ae81ff">15&lt;/span>
&lt;span style="color:#f92672">minReplicaCount&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#f92672">maxReplicaCount&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;span style="color:#f92672">triggers&lt;/span>:
- &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">kafka&lt;/span>
&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;span style="color:#f92672">topic&lt;/span>: &lt;span style="color:#ae81ff">demo-topic&lt;/span>
&lt;span style="color:#f92672">bootstrapServers&lt;/span>: &lt;span style="color:#ae81ff">kafka-cp-kafka.kafka.svc.cluster.local:9092&lt;/span>
&lt;span style="color:#f92672">consumerGroup&lt;/span>: &lt;span style="color:#ae81ff">autoscaling-subscriber&lt;/span>
&lt;span style="color:#f92672">lagThreshold&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;5&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面的文件中，这里有几点需要审视:&lt;/p>
&lt;ul>
&lt;li>&lt;code>spec:&lt;/code>中&lt;code>scaleTargetRef&lt;/code>部分的&lt;code>name&lt;/code>是您的应用程序在Deployment中定义的Dapr ID（&lt;code>dapr.io/id&lt;/code>注释的值）&lt;/li>
&lt;li>&lt;code>pollingInterval&lt;/code>是KEDA检查Kafka当前主题分区偏移量的以秒为单位的频率&lt;/li>
&lt;li>&lt;code>minReplicaCount&lt;/code>是KEDA为你的deployment创建的最小副本数量。 (注意，如果您的应用程序需要很长时间才能启动，最好将其设置为&lt;code>1&lt;/code>，以确保部署的至少一个副本始终在运行。 否则，设置为&lt;code>0&lt;/code>，KEDA就会为你创建第一个副本)&lt;/li>
&lt;li>&lt;code>maxReplicaCount&lt;/code>是你的deployment的最大副本数量。 考虑到 &lt;a href="http://cloudurable.com/blog/kafka-architecture-topics/index.html#:~:text=Kafka%20continually%20appended%20to%20partitions,fit%20on%20a%20single%20server.">Kafka分区偏移量&lt;/a>的工作方式，你不应该将该值设置得高于主题分区的总数量。&lt;/li>
&lt;li>Kafka &lt;code>metadata&lt;/code>部分的&lt;code>topic&lt;/code>应该设置为你的Dapr deployment所订阅的同一主题（在本例中&lt;code>demo-topic&lt;/code>）&lt;/li>
&lt;li>类似地，&lt;code>bootstrapServers&lt;/code>应该设置为&lt;code>kafka-pubsub.yaml&lt;/code>文件中使用的同一个broker的连接地址字符串&lt;/li>
&lt;li>&lt;code>consumerGroup&lt;/code>应该设置为与&lt;code>kafka-pubsub.yaml&lt;/code>文件中的&lt;code>consumerID&lt;/code>相同的值&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>注意：将 Dapr 服务订阅和 KEDA 缩放器配置的连接字符串、主题和消费者组设置为 &lt;em>相同的&lt;/em>值，对于确保自动缩放正常工作至关重要。&lt;/p>
&lt;/blockquote>
&lt;p>接下来，将KEDA扩展器部署到Kubernetes:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl apply -f kafka_scaler.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>全部完成！&lt;/p>
&lt;p>现在，&lt;code>ScaledObject&lt;/code> KEDA对象已经配置好了，你的deployment将根据Kafka主题的延迟进行扩展。 更多关于为Kafka主题配置KEDA的信息可以在&lt;a href="https://keda.sh/docs/2.0/scalers/apache-kafka/">这里&lt;/a>获得。&lt;/p>
&lt;p>现在你可以开始将消息发布到您的Kafka主题&lt;code>demo-topic&lt;/code>，当延迟阈值高于&lt;code>5&lt;/code>主题时，你可以看到pods开始自动缩放，正如我们在KEDA缩放器清单中定义的那样。 您可以通过使用Dapr &lt;a href="https://docs.dapr.io/reference/cli/dapr-publish/">Publish&lt;/a> CLI命令将消息发布到Kafka Dapr组件。&lt;/p></description></item><item><title>Developing-Applications: Dapr extension for Azure Functions runtime</title><link>https://docs.dapr.io/developing-applications/integrations/azure-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.dapr.io/developing-applications/integrations/azure-functions/</guid><description>
&lt;p>Dapr 通过扩展与 Azure Functions 运行时集成，使函数可以与 Dapr 无缝交互。 Azure Functions 提供事件驱动的编程模型， 而 Dapr 提供了云原生的构建块。 通过此扩展，您可以为无服务器和事件驱动的应用程序同时提供两者。 更多信息请阅读 &lt;a href="https://cloudblogs.microsoft.com/opensource/2020/07/01/announcing-azure-functions-extension-for-dapr/">用于 Dapr 的 Azure Functions扩展&lt;/a> 并访问 &lt;a href="https://github.com/dapr/azure-functions-extension">Azure Functions 扩展&lt;/a> 仓库以试用示例。&lt;/p></description></item><item><title>Developing-Applications: Running Dapr and Open Service Mesh together</title><link>https://docs.dapr.io/developing-applications/integrations/open-service-mesh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.dapr.io/developing-applications/integrations/open-service-mesh/</guid><description>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>&lt;a href="https://openservicemesh.io/">Open Service Mesh (OSM)&lt;/a> is a lightweight, extensible, cloud native service mesh that allows users to uniformly manage, secure, and get out-of-the-box observability features for highly dynamic microservice environments.&lt;/p>
&lt;a class="btn btn-primary" href="https://openservicemesh.io/" role="button">Learn more&lt;/a>
&lt;h2 id="dapr-integration">Dapr integration&lt;/h2>
&lt;p>Users are able to leverage both OSM SMI traffic policies and Dapr capabilities on the same Kubernetes cluster. Visit &lt;a href="https://docs.openservicemesh.io/docs/integrations/demo_dapr/">this guide&lt;/a> to get started.&lt;/p>
&lt;a class="btn btn-primary" href="https://docs.openservicemesh.io/docs/integrations/demo_dapr/" role="button">Deploy OSM and Dapr&lt;/a>
&lt;h2 id="example">Example&lt;/h2>
&lt;p>Watch the OSM team present the OSM and Dapr integration in the 05/18/2021 community call: &lt;iframe width="560" height="315" src="https://www.youtube.com/embed/LSYyTL0nS8Y?start=1916" title="YouTube 视频播放器" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen mark="crwd-mark">&lt;/iframe>&lt;/p>
&lt;h2 id="additional-resources">Additional resources&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://docs.dapr.io/concepts/service-mesh/">Dapr 和服务网格&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Developing-Applications: 使用Logic Apps构建工作流</title><link>https://docs.dapr.io/developing-applications/integrations/workflows/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.dapr.io/developing-applications/integrations/workflows/</guid><description>
&lt;p>Dapr Workflows is a lightweight host that allows developers to run cloud-native workflows locally, on-premises or any cloud environment using the &lt;a href="https://docs.microsoft.com/en-us/azure/logic-apps/logic-apps-overview">Azure Logic Apps&lt;/a> workflow engine and Dapr.&lt;/p>
&lt;h2 id="benefits">Benefits&lt;/h2>
&lt;p>By using a workflow engine, business logic can be defined in a declarative, no-code fashion so application code doesn&amp;rsquo;t need to change when a workflow changes. Dapr Workflows allows you to use workflows in a distributed application along with these added benefits:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Run workflows anywhere&lt;/strong>: on your local machine, on-premises, on Kubernetes or in the cloud&lt;/li>
&lt;li>&lt;strong>Built-in observability&lt;/strong>: tracing, metrics and mTLS through Dapr&lt;/li>
&lt;li>&lt;strong>gRPC and HTTP endpoints&lt;/strong> for your workflows&lt;/li>
&lt;li>Kick off workflows based on &lt;strong>Dapr bindings&lt;/strong> events&lt;/li>
&lt;li>Orchestrate complex workflows by &lt;strong>calling back to Dapr&lt;/strong> to save state, publish a message and more&lt;/li>
&lt;/ul>
&lt;img src="https://docs.dapr.io/images/workflows-diagram.png" width=500 alt="Diagram of Dapr Workflows">
&lt;h2 id="how-it-works">How it works&lt;/h2>
&lt;p>Dapr Workflows hosts a gRPC server that implements the Dapr Client API.&lt;/p>
&lt;p>This allows users to start workflows using gRPC and HTTP endpoints through Dapr, or start a workflow asynchronously using Dapr bindings. Once a workflow request comes in, Dapr Workflows uses the Logic Apps SDK to execute the workflow.&lt;/p>
&lt;h2 id="supported-workflow-features">Supported workflow features&lt;/h2>
&lt;h3 id="supported-actions-and-triggers">Supported actions and triggers&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/azure/connectors/connectors-native-http">HTTP&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/azure/logic-apps/concepts-schedule-automated-recurring-tasks-workflows">Schedule&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/azure/connectors/connectors-native-reqres">Request / Response&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="supported-control-workflows">Supported control workflows&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/azure/connectors/apis-list#control-workflow">All control workflows&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="supported-data-manipulation">Supported data manipulation&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/azure/connectors/apis-list#manage-or-manipulate-data">All data operations&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="not-supported">Not supported&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/azure/connectors/apis-list#managed-connectors">Managed connectors&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="example">Example&lt;/h2>
&lt;p>Dapr Workflows can be used as the orchestrator for many otherwise complex activities. For example, invoking an external endpoint, saving the data to a state store, publishing the result to a different app or invoking a binding can all be done by calling back into Dapr from the workflow itself.&lt;/p>
&lt;p>This is due to the fact Dapr runs as a sidecar next to the workflow host just as if it was any other app.&lt;/p>
&lt;p>Examine &lt;a href="https://docs.dapr.io/code/workflow.json">workflow2.json&lt;/a> as an example of a workflow that does the following:&lt;/p>
&lt;ol>
&lt;li>Calls into Azure Functions to get a JSON response&lt;/li>
&lt;li>Saves the result to a Dapr state store&lt;/li>
&lt;li>Sends the result to a Dapr binding&lt;/li>
&lt;li>Returns the result to the caller&lt;/li>
&lt;/ol>
&lt;p>Since Dapr supports many pluggable state stores and bindings, the workflow becomes portable between different environments (cloud, edge or on-premises) without the user changing the code - &lt;em>because there is no code involved&lt;/em>.&lt;/p>
&lt;h2 id="get-started">Get started&lt;/h2>
&lt;p>前期准备:&lt;/p>
&lt;ol>
&lt;li>Install the &lt;a href="https://docs.dapr.io/getting-started/install-dapr-cli/">Dapr CLI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-create-account-block-blob?tabs=azure-portal">Azure blob storage account&lt;/a>&lt;/li>
&lt;/ol>
&lt;h3 id="自托管">自托管&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>Make sure you have the Dapr runtime initialized:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">dapr init
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Set up the environment variables containing the Azure Storage Account credentials:&lt;/p>
&lt;ul class="nav nav-tabs" id="tabs-1" role="tablist">&lt;li class="nav-item">&lt;a class="nav-link active"
id="tabs-1-windows-tab" data-toggle="tab" href="#tabs-1-windows" role="tab"
aria-controls="tabs-1-windows" aria-selected="true">
Windows
&lt;/a>
&lt;/li>&lt;li class="nav-item">&lt;a class="nav-link"
id="tabs-1-macoslinux-tab" data-toggle="tab" href="#tabs-1-macoslinux" role="tab"
aria-controls="tabs-1-macoslinux" aria-selected="false">
macOS/Linux
&lt;/a>
&lt;/li>&lt;/ul>
&lt;div class="tab-content" id="tabs-1-content">
&lt;div class="tab-pane fade show active" id="tabs-1-windows" role="tabpanel" aria-labelled-by="tabs-1-windows-tab">
&lt;br />&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">export STORAGE_ACCOUNT_KEY&lt;span style="color:#f92672">=&lt;/span>&amp;lt;YOUR-STORAGE-ACCOUNT-KEY&amp;gt;
export STORAGE_ACCOUNT_NAME&lt;span style="color:#f92672">=&lt;/span>&amp;lt;YOUR-STORAGE-ACCOUNT-NAME&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;div class="tab-pane fade" id="tabs-1-macoslinux" role="tabpanel" aria-labelled-by="tabs-1-macoslinux-tab">
&lt;br />&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">set STORAGE_ACCOUNT_KEY&lt;span style="color:#f92672">=&lt;/span>&amp;lt;YOUR-STORAGE-ACCOUNT-KEY&amp;gt;
set STORAGE_ACCOUNT_NAME&lt;span style="color:#f92672">=&lt;/span>&amp;lt;YOUR-STORAGE-ACCOUNT-NAME&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Move to the workflows directory and run the sample runtime:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">cd src/Dapr.Workflows
dapr run --app-id workflows --protocol grpc --port &lt;span style="color:#ae81ff">3500&lt;/span> --app-port &lt;span style="color:#ae81ff">50003&lt;/span> -- dotnet run --workflows-path ../../samples
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Invoke a workflow:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl http://localhost:3500/v1.0/invoke/workflows/method/workflow1
&lt;span style="color:#f92672">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;value&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;Hello from Logic App workflow running with Dapr!&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="kubernetes">Kubernetes&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>Make sure you have a running Kubernetes cluster and &lt;code>kubectl&lt;/code> in your path.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Once you have the Dapr CLI installed, run:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">dapr init --kubernetes
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Wait until the Dapr pods have the status &lt;code>Running&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Create a Config Map for the workflow:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl create configmap workflows --from-file ./samples/workflow1. json
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Create a secret containing the Azure Storage Account credentials. Replace the account name and key values below with the actual credentials:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl create secret generic dapr-workflows --from-literal&lt;span style="color:#f92672">=&lt;/span>accountName&lt;span style="color:#f92672">=&lt;/span>&amp;lt;YOUR-STORAGE-ACCOUNT-NAME&amp;gt; --from-literal&lt;span style="color:#f92672">=&lt;/span>accountKey&lt;span style="color:#f92672">=&lt;/span>&amp;lt;YOUR-STORAGE-ACCOUNT-KEY&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Deploy Dapr Worfklows:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl apply -f deploy/deploy.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Create a port-forward to the dapr workflows container:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl port-forward deploy/dapr-workflows-host 3500:3500
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Invoke logic apps through Dapr:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl http://localhost:3500/v1.0/invoke/workflows/method/workflow1
&lt;span style="color:#f92672">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;value&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;Hello from Logic App workflow running with Dapr!&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="invoking-workflows-using-dapr-bindings">Invoking workflows using Dapr bindings&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>First, create any &lt;a href="https://docs.dapr.io/reference/components-reference/">Dapr binding&lt;/a> of your choice. See &lt;a href="https://docs.dapr.io/developing-applications/building-blocks/bindings/howto-triggers/">this&lt;/a> How-To tutorial.&lt;/p>
&lt;p>In order for Dapr Workflows to be able to start a workflow from a Dapr binding event, simply name the binding with the name of the workflow you want it to trigger.&lt;/p>
&lt;p>Here&amp;rsquo;s an example of a Kafka binding that will trigger a workflow named &lt;code>workflow1&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">dapr.io/v1alpha1&lt;/span>
&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Component&lt;/span>
&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">workflow1&lt;/span>
&lt;span style="color:#f92672">spec&lt;/span>:
&lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">bindings.kafka&lt;/span>
&lt;span style="color:#f92672">metadata&lt;/span>:
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">topics&lt;/span>
&lt;span style="color:#f92672">value&lt;/span>: &lt;span style="color:#ae81ff">topic1&lt;/span>
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">brokers&lt;/span>
&lt;span style="color:#f92672">value&lt;/span>: &lt;span style="color:#ae81ff">localhost:9092&lt;/span>
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">consumerGroup&lt;/span>
&lt;span style="color:#f92672">value&lt;/span>: &lt;span style="color:#ae81ff">group1&lt;/span>
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">authRequired&lt;/span>
&lt;span style="color:#f92672">value&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;false&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Next, apply the Dapr component:&lt;/p>
&lt;ul class="nav nav-tabs" id="tabs-4" role="tablist">&lt;li class="nav-item">&lt;a class="nav-link active"
id="tabs-4-self-hosted-tab" data-toggle="tab" href="#tabs-4-self-hosted" role="tab"
aria-controls="tabs-4-self-hosted" aria-selected="true">
Self-hosted
&lt;/a>
&lt;/li>&lt;li class="nav-item">&lt;a class="nav-link"
id="tabs-4-kubernetes-tab" data-toggle="tab" href="#tabs-4-kubernetes" role="tab"
aria-controls="tabs-4-kubernetes" aria-selected="false">
Kubernetes
&lt;/a>
&lt;/li>&lt;/ul>
&lt;div class="tab-content" id="tabs-4-content">
&lt;div class="tab-pane fade show active" id="tabs-4-self-hosted" role="tabpanel" aria-labelled-by="tabs-4-self-hosted-tab">
&lt;br />&lt;p>Place the binding yaml file above in a &lt;code>components&lt;/code> directory at the root of your application.&lt;/p>
&lt;/div>
&lt;div class="tab-pane fade" id="tabs-4-kubernetes" role="tabpanel" aria-labelled-by="tabs-4-kubernetes-tab">
&lt;br />&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl apply -f my_binding.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>Once an event is sent to the bindings component, check the logs Dapr Workflows to see the output.&lt;/p>
&lt;ul class="nav nav-tabs" id="tabs-5" role="tablist">&lt;li class="nav-item">&lt;a class="nav-link active"
id="tabs-5-self-hosted-tab" data-toggle="tab" href="#tabs-5-self-hosted" role="tab"
aria-controls="tabs-5-self-hosted" aria-selected="true">
Self-hosted
&lt;/a>
&lt;/li>&lt;li class="nav-item">&lt;a class="nav-link"
id="tabs-5-kubernetes-tab" data-toggle="tab" href="#tabs-5-kubernetes" role="tab"
aria-controls="tabs-5-kubernetes" aria-selected="false">
Kubernetes
&lt;/a>
&lt;/li>&lt;/ul>
&lt;div class="tab-content" id="tabs-5-content">
&lt;div class="tab-pane fade show active" id="tabs-5-self-hosted" role="tabpanel" aria-labelled-by="tabs-5-self-hosted-tab">
&lt;br />&lt;p>In standalone mode, the output will be printed to the local terminal.&lt;/p>
&lt;/div>
&lt;div class="tab-pane fade" id="tabs-5-kubernetes" role="tabpanel" aria-labelled-by="tabs-5-kubernetes-tab">
&lt;br />&lt;p>On Kubernetes, run the following command:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl logs -l app&lt;span style="color:#f92672">=&lt;/span>dapr-workflows-host -c host
&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;h2 id="example-1">Example&lt;/h2>
&lt;p>Watch an example from the Dapr community call: &lt;iframe width="560" height="315" src="https://www.youtube.com/embed/7fP-0Ixmi-w?start=116" title="YouTube 视频播放器" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen mark="crwd-mark">&lt;/iframe>&lt;/p>
&lt;h2 id="additional-resources">Additional resources&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://cloudblogs.microsoft.com/opensource/2020/05/26/announcing-cloud-native-workflows-dapr-logic-apps/">Blog announcement&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/dapr/workflows">Repo&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Developing-Applications: 与云提供商的集成</title><link>https://docs.dapr.io/developing-applications/integrations/cloud-providers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.dapr.io/developing-applications/integrations/cloud-providers/</guid><description/></item><item><title>Developing-Applications: Dapr integration policies for Azure API Management</title><link>https://docs.dapr.io/developing-applications/integrations/azure-api-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.dapr.io/developing-applications/integrations/azure-api-management/</guid><description>
&lt;p>Azure API Management (APIM) is a way to create consistent and modern API gateways for back-end services, including as those built with Dapr. Dapr support can be enabled in self-hosted API Management gateways to allow them to forward requests to Dapr services, send messages to Dapr Pub/Sub topics, or trigger Dapr output bindings. For more information, read the guide on &lt;a href="https://docs.microsoft.com/en-us/azure/api-management/api-management-dapr-policies">API Management Dapr Integration policies&lt;/a> and try out the &lt;a href="https://github.com/dapr/samples/tree/master/dapr-apim-integration">Dapr &amp;amp; Azure API Management Integration Demo&lt;/a>.&lt;/p>
&lt;a class="btn btn-primary" href="https://docs.microsoft.com/en-us/azure/api-management/api-management-dapr-policies" role="button">Learn more&lt;/a></description></item></channel></rss>