<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dapr 文档库 – Dapr actors .NET SDK入门</title><link>https://docs.dapr.io/developing-applications/sdks/dotnet/dotnet-actors/</link><description>Recent content in Dapr actors .NET SDK入门 on Dapr 文档库</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://docs.dapr.io/developing-applications/sdks/dotnet/dotnet-actors/index.xml" rel="self" type="application/rss+xml"/><item><title>Developing-Applications: Dapr actor .NET SDK入门</title><link>https://docs.dapr.io/developing-applications/sdks/dotnet/dotnet-actors/dotnet-actor-howto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.dapr.io/developing-applications/sdks/dotnet/dotnet-actors/dotnet-actor-howto/</guid><description>
&lt;h2 id="前期准备">前期准备&lt;/h2>
&lt;ul>
&lt;li>安装 &lt;a href="https://docs.dapr.io/getting-started/install-dapr-cli/">Dapr CLI&lt;/a>&lt;/li>
&lt;li>初始化后的 &lt;a href="https://docs.dapr.io/getting-started/install-dapr-selfhost/">Dapr 环境&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dotnet.microsoft.com/download">.NET Core 3.1 or .NET 5+&lt;/a> 已安装&lt;/li>
&lt;/ul>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>本文档描述了如何创建一个Actor(&lt;code>MyActor&lt;/code>) 并从客户端程序调用其方法。&lt;/p>
&lt;pre>&lt;code>MyActor --- MyActor.Interfaces
|
+- MyActorService
|
+- MyActorClient
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>&lt;strong>接口项目(\MyActor\MyActor.Interfaces).&lt;/strong> 该项目包含了actor的接口定义。 Actor接口可以在任何项目中以任意的名称定义。 它定义了actor的实现和调用actor的客户端之间的约定。 由于客户端项目可能会依赖它，所以在一个和actor实现分隔开的程序集中定义通常是有意义的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Actor服务项目 (\MyActor\MyActorService)。&lt;/strong> 该项目实现了Asp.Net Core web service，用于托管actor。 它包含了actor的实现，MyActor.cs。 Actor的实现是一个继承了基类Actor并且实现了Myactor.Interfaces项目中定义的接口的类。 Actor还必须提供接受一个ActorService实例和ActorId的构造函数，并将他们传递给基类。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>演员客户端项目 (\MyActor\MyActorClient)。&lt;/strong> 该项目包含了actor客户端的实现，并在其中调用了在Actor接口中定义的方法。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="step1---创建actor接口">STEP1 - 创建Actor接口&lt;/h2>
&lt;p>Actor接口定义了actor的实现和调用actor的客户端之间的约定。&lt;/p>
&lt;p>Actor接口的定义需要满足以下要求：&lt;/p>
&lt;ul>
&lt;li>Actor接口必须继承 &lt;code>Dapr.Actors.IActor&lt;/code> 接口&lt;/li>
&lt;li>Actor方法的返回值必须是&lt;code>Task&lt;/code> 或者 &lt;code>Task&amp;lt;object&amp;gt;&lt;/code>类型&lt;/li>
&lt;li>Actor方法最多只能有一个参数&lt;/li>
&lt;/ul>
&lt;h3 id="创建项目并添加依赖">创建项目并添加依赖&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># Create Actor Interfaces&lt;/span>
dotnet new classlib -o MyActor.Interfaces
cd MyActor.Interfaces
&lt;span style="color:#75715e"># Add Dapr.Actors nuget package. Please use the latest package version from nuget.org&lt;/span>
dotnet add package Dapr.Actors -v 1.0.0-rc02
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="定义imyactor接口">定义IMyActor接口&lt;/h3>
&lt;p>定义IMyActor接口和MyData数据对象.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="color:#66d9ef">using&lt;/span> Dapr.Actors;
&lt;span style="color:#66d9ef">using&lt;/span> System.Threading.Tasks;
&lt;span style="color:#66d9ef">namespace&lt;/span> MyActor.Interfaces
{
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> IMyActor : IActor
{
Task&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>&amp;gt; SetDataAsync(MyData data);
Task&amp;lt;MyData&amp;gt; GetDataAsync();
Task RegisterReminder();
Task UnregisterReminder();
Task RegisterTimer();
Task UnregisterTimer();
}
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyData&lt;/span>
{
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> PropertyA { &lt;span style="color:#66d9ef">get&lt;/span>; &lt;span style="color:#66d9ef">set&lt;/span>; }
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> PropertyB { &lt;span style="color:#66d9ef">get&lt;/span>; &lt;span style="color:#66d9ef">set&lt;/span>; }
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> ToString()
{
&lt;span style="color:#66d9ef">var&lt;/span> propAValue = &lt;span style="color:#66d9ef">this&lt;/span>.PropertyA == &lt;span style="color:#66d9ef">null&lt;/span> ? &lt;span style="color:#e6db74">&amp;#34;null&amp;#34;&lt;/span> : &lt;span style="color:#66d9ef">this&lt;/span>.PropertyA;
&lt;span style="color:#66d9ef">var&lt;/span> propBValue = &lt;span style="color:#66d9ef">this&lt;/span>.PropertyB == &lt;span style="color:#66d9ef">null&lt;/span> ? &lt;span style="color:#e6db74">&amp;#34;null&amp;#34;&lt;/span> : &lt;span style="color:#66d9ef">this&lt;/span>.PropertyB;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">$&amp;#34;PropertyA: {propAValue}, PropertyB: {propBValue}&amp;#34;&lt;/span>;
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="step2---创建actor服务">STEP2 - 创建Actor服务&lt;/h2>
&lt;p>Dapr 使用 ASP.NET web service来托管Actor服务。 本节将会实现&lt;code>IMyActor&lt;/code>接口并将Actor注册到Dapr Runtime。&lt;/p>
&lt;h3 id="创建项目并添加依赖-1">创建项目并添加依赖&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># Create ASP.Net Web service to host Dapr actor&lt;/span>
dotnet new webapi -o MyActorService
cd MyActorService
&lt;span style="color:#75715e"># Add Dapr.Actors nuget package. Please use the latest package version from nuget.org&lt;/span>
dotnet add package Dapr.Actors -v 1.0.0-rc02
&lt;span style="color:#75715e"># Add Dapr.Actors.AspNetCore nuget package. Please use the latest package version from nuget.org&lt;/span>
dotnet add package Dapr.Actors.AspNetCore -v 1.0.0-rc02
&lt;span style="color:#75715e"># Add Actor Interface reference&lt;/span>
dotnet add reference ../MyActor.Interfaces/MyActor.Interfaces.csproj
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="添加actor实现">添加Actor实现&lt;/h3>
&lt;p>实现IMyActor接口并继承自 &lt;code>Dapr.Actors.Actor&lt;/code> 。 下面的例子同样展示了如何使用Actor Reminders。 Actor如果要使用Reminders，则必须实现IRemindable接口 如果你不打算使用Reminder功能，你可以跳过下面代码中实现IRemindable接口和Reminder特定方法的操作。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="color:#66d9ef">using&lt;/span> Dapr.Actors;
&lt;span style="color:#66d9ef">using&lt;/span> Dapr.Actors.Runtime;
&lt;span style="color:#66d9ef">using&lt;/span> MyActor.Interfaces;
&lt;span style="color:#66d9ef">using&lt;/span> System;
&lt;span style="color:#66d9ef">using&lt;/span> System.Threading.Tasks;
&lt;span style="color:#66d9ef">namespace&lt;/span> MyActorService
{
&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyActor&lt;/span> : Actor, IMyActor, IRemindable
{
&lt;span style="color:#75715e">// The constructor must accept ActorHost as a parameter, and can also accept additional
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// parameters that will be retrieved from the dependency injection container
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// Initializes a new instance of MyActor
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// &amp;lt;/summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">///
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> MyActor(ActorHost host)
: &lt;span style="color:#66d9ef">base&lt;/span>(host)
{
}
&lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// This method is called whenever an actor is activated.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// An actor is activated the first time any of its methods are invoked.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// &amp;lt;/summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> Task OnActivateAsync()
{
&lt;span style="color:#75715e">// Provides opportunity to perform some optional setup.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Console.WriteLine(&lt;span style="color:#e6db74">$&amp;#34;Activating actor id: {this.Id}&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> Task.CompletedTask;
}
&lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// This method is called whenever an actor is deactivated after a period of inactivity.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// &amp;lt;/summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> Task OnDeactivateAsync()
{
&lt;span style="color:#75715e">// Provides Opporunity to perform optional cleanup.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Console.WriteLine(&lt;span style="color:#e6db74">$&amp;#34;Deactivating actor id: {this.Id}&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> Task.CompletedTask;
}
&lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// Set MyData into actor&amp;#39;s private state store
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// &amp;lt;/summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">///
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task&amp;lt;&lt;span style="color:#66d9ef">string&lt;/span>&amp;gt; SetDataAsync(MyData data)
{
&lt;span style="color:#75715e">// Data is saved to configured state store implicitly after each method execution by Actor&amp;#39;s runtime.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Data can also be saved explicitly by calling this.StateManager.SaveStateAsync();
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// State to be saved must be DataContract serializable.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.StateManager.SetStateAsync&amp;lt;MyData&amp;gt;(
&lt;span style="color:#e6db74">&amp;#34;my_data&amp;#34;&lt;/span>, &lt;span style="color:#75715e">// state name
&lt;/span>&lt;span style="color:#75715e">&lt;/span> data); &lt;span style="color:#75715e">// data saved for the named state &amp;#34;my_data&amp;#34;
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Success&amp;#34;&lt;/span>;
}
&lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// Get MyData from actor&amp;#39;s private state store
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// &amp;lt;/summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// &amp;lt;return&amp;gt;the user-defined MyData which is stored into state store as &amp;#34;my_data&amp;#34; state&amp;lt;/return&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> Task&amp;lt;MyData&amp;gt; GetDataAsync()
{
&lt;span style="color:#75715e">// Gets state from the state store.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.StateManager.GetStateAsync&amp;lt;MyData&amp;gt;(&lt;span style="color:#e6db74">&amp;#34;my_data&amp;#34;&lt;/span>);
}
&lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// Register MyReminder reminder with the actor
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// &amp;lt;/summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task RegisterReminder()
{
&lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.RegisterReminderAsync(
&lt;span style="color:#e6db74">&amp;#34;MyReminder&amp;#34;&lt;/span>, &lt;span style="color:#75715e">// The name of the reminder
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#75715e">// User state passed to IRemindable.ReceiveReminderAsync()
&lt;/span>&lt;span style="color:#75715e">&lt;/span> TimeSpan.FromSeconds(&lt;span style="color:#ae81ff">5&lt;/span>), &lt;span style="color:#75715e">// Time to delay before invoking the reminder for the first time
&lt;/span>&lt;span style="color:#75715e">&lt;/span> TimeSpan.FromSeconds(&lt;span style="color:#ae81ff">5&lt;/span>)); &lt;span style="color:#75715e">// Time interval between reminder invocations after the first invocation
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
&lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// Unregister MyReminder reminder with the actor
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// &amp;lt;/summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> Task UnregisterReminder()
{
Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Unregistering MyReminder...&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.UnregisterReminderAsync(&lt;span style="color:#e6db74">&amp;#34;MyReminder&amp;#34;&lt;/span>);
}
&lt;span style="color:#75715e">// &amp;lt;summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Implement IRemindeable.ReceiveReminderAsync() which is call back invoked when an actor reminder is triggered.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// &amp;lt;/summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> Task ReceiveReminderAsync(&lt;span style="color:#66d9ef">string&lt;/span> reminderName, &lt;span style="color:#66d9ef">byte&lt;/span>[] state, TimeSpan dueTime, TimeSpan period)
{
Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;ReceiveReminderAsync is called!&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> Task.CompletedTask;
}
&lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// Register MyTimer timer with the actor
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// &amp;lt;/summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> Task RegisterTimer()
{
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.RegisterTimerAsync(
&lt;span style="color:#e6db74">&amp;#34;MyTimer&amp;#34;&lt;/span>, &lt;span style="color:#75715e">// The name of the timer
&lt;/span>&lt;span style="color:#75715e">&lt;/span> nameof(&lt;span style="color:#66d9ef">this&lt;/span>.OnTimerCallBack), &lt;span style="color:#75715e">// Timer callback
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#75715e">// User state passed to OnTimerCallback()
&lt;/span>&lt;span style="color:#75715e">&lt;/span> TimeSpan.FromSeconds(&lt;span style="color:#ae81ff">5&lt;/span>), &lt;span style="color:#75715e">// Time to delay before the async callback is first invoked
&lt;/span>&lt;span style="color:#75715e">&lt;/span> TimeSpan.FromSeconds(&lt;span style="color:#ae81ff">5&lt;/span>)); &lt;span style="color:#75715e">// Time interval between invocations of the async callback
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
&lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// Unregister MyTimer timer with the actor
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// &amp;lt;/summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> Task UnregisterTimer()
{
Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Unregistering MyTimer...&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.UnregisterTimerAsync(&lt;span style="color:#e6db74">&amp;#34;MyTimer&amp;#34;&lt;/span>);
}
&lt;span style="color:#75715e">/// &amp;lt;summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// Timer callback once timer is expired
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/// &amp;lt;/summary&amp;gt;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> Task OnTimerCallBack(&lt;span style="color:#66d9ef">byte&lt;/span>[] data)
{
Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;OnTimerCallBack is called!&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> Task.CompletedTask;
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="使用显式的actor类型名称">使用显式的actor类型名称&lt;/h4>
&lt;p>默认情况下，客户端所看到的actor的“类型”来自actor实现类的名称。 如果需要，你可以通过向actor实现类附加一个 &lt;code>ActorAttribute&lt;/code> 特性来指定一个显式的类型名称。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="color:#a6e22e"> [Actor(TypeName = &amp;#34;MyCustomActorTypeName&amp;#34;)]&lt;/span>
&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyActor&lt;/span> : Actor, IMyActor
{
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用aspnet-core-startup来注册actor-runtime">使用ASP.NET Core Startup来注册Actor runtime&lt;/h3>
&lt;p>Actor runtime使用ASP.NET Core &lt;code>Startup.cs&lt;/code>来配置。&lt;/p>
&lt;p>运行时使用ASP.NET Core依赖注入系统来注册actor类型和基本服务。 通过在 &lt;code>ConfigureServices(...)&lt;/code> 中调用 &lt;code>AddActors(...)&lt;/code> 方法来提供这种集成。 使用传递到 &lt;code>AddActors(...)&lt;/code> 方法的委托来注册actor类型并配置actor运行时设置。 你可以在&lt;code>ConfigureServices(...)&lt;/code>中为依赖注入注册额外的类型。 它们都可以被注入到你的Actor类型的构造器。&lt;/p>
&lt;p>Actors通过Dapr runtime使用HTTP调用来实现。 此功能是应用程序的 HTTP 处理管道的一部分，在 &lt;code>Configure(...)&lt;/code> 方法中的&lt;code>UseEndpoint(...)&lt;/code> 注册。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-csharp" data-lang="csharp"> &lt;span style="color:#75715e">// In Startup.cs
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> ConfigureServices(IServiceCollection services)
{
&lt;span style="color:#75715e">// Register actor runtime with DI
&lt;/span>&lt;span style="color:#75715e">&lt;/span> services.AddActors(options =&amp;gt;
{
&lt;span style="color:#75715e">// Register actor types and configure actor settings
&lt;/span>&lt;span style="color:#75715e">&lt;/span> options.Actors.RegisterActor&amp;lt;MyActor&amp;gt;();
});
&lt;span style="color:#75715e">// Register additional services for use with actors
&lt;/span>&lt;span style="color:#75715e">&lt;/span> services.AddSingleton&amp;lt;BankService&amp;gt;();
}
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
&lt;span style="color:#66d9ef">if&lt;/span> (env.IsDevelopment())
{
app.UseDeveloperExceptionPage();
}
&lt;span style="color:#66d9ef">else&lt;/span>
{
app.UseHsts();
}
app.UseRouting();
app.UseEndpoints(endpoints =&amp;gt;
{
&lt;span style="color:#75715e">// Register actors handlers that interface with the Dapr runtime.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> endpoints.MapActorsHandlers();
});
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="可选---覆盖默认的actor设置">&lt;strong>可选&lt;/strong> - 覆盖默认的Actor设置&lt;/h3>
&lt;p>Actor的设置针对每个应用程序。 在&lt;a href="https://docs.dapr.io/reference/api/actors_api/">此处&lt;/a> 描述的设置在options中可用的并可以通过如下方式来修改。&lt;/p>
&lt;p>下面的代码扩展了上一节来做这件事。 请注意下面的值仅用于 &lt;strong>示例&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-csharp" data-lang="csharp">
&lt;span style="color:#75715e">// In Startup.cs
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> ConfigureServices(IServiceCollection services)
{
&lt;span style="color:#75715e">// Register actor runtime with DI
&lt;/span>&lt;span style="color:#75715e">&lt;/span> services.AddActors(options =&amp;gt;
{
&lt;span style="color:#75715e">// Register actor types and configure actor settings
&lt;/span>&lt;span style="color:#75715e">&lt;/span> options.Actors.RegisterActor&amp;lt;MyActor&amp;gt;();
options.ActorIdleTimeout = TimeSpan.FromMinutes(&lt;span style="color:#ae81ff">10&lt;/span>);
options.ActorScanInterval = TimeSpan.FromSeconds(&lt;span style="color:#ae81ff">35&lt;/span>);
options.DrainOngoingCallTimeout = TimeSpan.FromSeconds(&lt;span style="color:#ae81ff">35&lt;/span>);
options.DrainRebalancedActors = &lt;span style="color:#66d9ef">true&lt;/span>;
});
&lt;span style="color:#75715e">// Register additional services for use with actors
&lt;/span>&lt;span style="color:#75715e">&lt;/span> services.AddSingleton&amp;lt;BankService&amp;gt;();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="step-3---添加客户端">STEP 3 - 添加客户端&lt;/h2>
&lt;p>创建一个简单的控制台应用来调用actor服务。 Dapr SDK 提供 Actor 代理客户端来调用Actor接口中定义的actor方法。&lt;/p>
&lt;h3 id="创建项目并添加依赖-2">创建项目并添加依赖&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># Create Actor&amp;#39;s Client&lt;/span>
dotnet new console -o MyActorClient
cd MyActorClient
&lt;span style="color:#75715e"># Add Dapr.Actors nuget package. Please use the latest package version from nuget.org&lt;/span>
dotnet add package Dapr.Actors -v 1.0.0-rc02
&lt;span style="color:#75715e"># Add Actor Interface reference&lt;/span>
dotnet add reference ../MyActor.Interfaces/MyActor.Interfaces.csproj
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用-actor-服务远程调用-actor-方法">使用 Actor 服务远程调用 Actor 方法&lt;/h3>
&lt;p>我们建议使用actor实例的本地代理，因为 &lt;code>ActorProxy.Create&amp;lt;IMyActor&amp;gt;(actorID, actorType)&lt;/code>返回强类型的actor实例来配置远程过程调用。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="color:#66d9ef">namespace&lt;/span> MyActorClient
{
&lt;span style="color:#66d9ef">using&lt;/span> Dapr.Actors;
&lt;span style="color:#66d9ef">using&lt;/span> Dapr.Actors.Client;
&lt;span style="color:#66d9ef">using&lt;/span> MyActor.Interfaces;
&lt;span style="color:#66d9ef">using&lt;/span> System;
&lt;span style="color:#66d9ef">using&lt;/span> System.Threading.Tasks;
...
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task InvokeActorMethodWithRemotingAsync()
{
&lt;span style="color:#66d9ef">var&lt;/span> actorType = &lt;span style="color:#e6db74">&amp;#34;MyActor&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Registered Actor Type in Actor Service
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> actorID = &lt;span style="color:#66d9ef">new&lt;/span> ActorId(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
&lt;span style="color:#75715e">// Create the local proxy by using the same interface that the service implements
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// By using this proxy, you can call strongly typed methods on the interface using Remoting.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> proxy = ActorProxy.Create&amp;lt;IMyActor&amp;gt;(actorID, actorType);
&lt;span style="color:#66d9ef">var&lt;/span> response = &lt;span style="color:#66d9ef">await&lt;/span> proxy.SetDataAsync(&lt;span style="color:#66d9ef">new&lt;/span> MyData()
{
PropertyA = &lt;span style="color:#e6db74">&amp;#34;ValueA&amp;#34;&lt;/span>,
PropertyB = &lt;span style="color:#e6db74">&amp;#34;ValueB&amp;#34;&lt;/span>,
});
Console.WriteLine(response);
&lt;span style="color:#66d9ef">var&lt;/span> savedData = &lt;span style="color:#66d9ef">await&lt;/span> proxy.GetDataAsync();
Console.WriteLine(savedData);
}
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="无-actor-服务远程调用-actor-方法">无 Actor 服务远程调用 Actor 方法&lt;/h3>
&lt;p>如果actor方法接受最多一个参数，您可以无需使用remoting来调用actor方法(直接通过 http 或使用 ActorProxy 提供的辅助方法)。 Actor 运行时将会反序列化从客户端接收到的请求体，并将其作为方法参数来调用actor方法。 当进行non-remoting调用，Actor方法参数和返回值会被序列化，反序列化为 JSON 。&lt;/p>
&lt;p>&lt;code>ActorProxy.Create(actorID, actorType)&lt;/code> 返回ActorProxy实例，并且可以使用原始的http client 来调用在 &lt;code>IMyActor&lt;/code>中定义的方法。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="color:#66d9ef">namespace&lt;/span> MyActorClient
{
&lt;span style="color:#66d9ef">using&lt;/span> Dapr.Actors;
&lt;span style="color:#66d9ef">using&lt;/span> Dapr.Actors.Client;
&lt;span style="color:#66d9ef">using&lt;/span> MyActor.Interfaces;
&lt;span style="color:#66d9ef">using&lt;/span> System;
&lt;span style="color:#66d9ef">using&lt;/span> System.Threading.Tasks;
...
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task InvokeActorMethodWithoutRemotingAsync()
{
&lt;span style="color:#66d9ef">var&lt;/span> actorType = &lt;span style="color:#e6db74">&amp;#34;MyActor&amp;#34;&lt;/span>;
&lt;span style="color:#66d9ef">var&lt;/span> actorID = &lt;span style="color:#66d9ef">new&lt;/span> ActorId(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
&lt;span style="color:#75715e">// Create Actor Proxy instance to invoke the methods defined in the interface
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> proxy = ActorProxy.Create(actorID, actorType);
&lt;span style="color:#75715e">// Need to specify the method name and response type explicitly
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> response = &lt;span style="color:#66d9ef">await&lt;/span> proxy.InvokeMethodAsync&amp;lt;MyData, &lt;span style="color:#66d9ef">string&lt;/span>&amp;gt;(&lt;span style="color:#e6db74">&amp;#34;SetDataAsync&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">new&lt;/span> MyData()
{
PropertyA = &lt;span style="color:#e6db74">&amp;#34;ValueA&amp;#34;&lt;/span>,
PropertyB = &lt;span style="color:#e6db74">&amp;#34;ValueB&amp;#34;&lt;/span>,
});
Console.WriteLine(response);
&lt;span style="color:#66d9ef">var&lt;/span> savedData = &lt;span style="color:#66d9ef">await&lt;/span> proxy.InvokeMethodAsync&amp;lt;MyData&amp;gt;(&lt;span style="color:#e6db74">&amp;#34;GetDataAsync&amp;#34;&lt;/span>);
Console.WriteLine(savedData);
}
...
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="运行-actor">运行 Actor&lt;/h2>
&lt;p>为了验证和调试执行者服务和客户端，我们需要先通过 Dapr CLI 运行 actor 服务。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>通过 Dapr cli 运行 Dapr&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ dapr run --app-id myapp --app-port &lt;span style="color:#ae81ff">5000&lt;/span> --dapr-http-port &lt;span style="color:#ae81ff">3500&lt;/span> dotnet run
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过 Dapr 运行时执行 MyActorService 后，请确保应用程序在 5000 端口被发现，并成功建立actor连接。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash"> INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> starting Dapr Runtime -- version -- commit
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> log level set to: info
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> standalone mode configured
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> dapr id: myapp
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> loaded component statestore &lt;span style="color:#f92672">(&lt;/span>state.redis&lt;span style="color:#f92672">)&lt;/span>
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> application protocol: http. waiting on port &lt;span style="color:#ae81ff">5000&lt;/span>
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> application discovered on port &lt;span style="color:#ae81ff">5000&lt;/span>
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> application configuration loaded
2019/08/27 14:42:06 redis: connecting to localhost:6379
2019/08/27 14:42:06 redis: connected to localhost:6379 &lt;span style="color:#f92672">(&lt;/span>localAddr: &lt;span style="color:#f92672">[&lt;/span>::1&lt;span style="color:#f92672">]&lt;/span>:53155, remAddr: &lt;span style="color:#f92672">[&lt;/span>::1&lt;span style="color:#f92672">]&lt;/span>:6379&lt;span style="color:#f92672">)&lt;/span>
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> actor runtime started. actor idle timeout: 1h0m0s. actor scan interval: 30s
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> actors: starting connection attempt to placement service at localhost:50005
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> http server is running on port &lt;span style="color:#ae81ff">3500&lt;/span>
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> gRPC server is running on port &lt;span style="color:#ae81ff">50001&lt;/span>
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> dapr initialized. Status: Running. Init Elapsed 19.699438ms
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> actors: established connection to placement service at localhost:50005
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> actors: placement order received: lock
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> actors: placement order received: update
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> actors: placement tables updated
INFO&lt;span style="color:#f92672">[&lt;/span>0000&lt;span style="color:#f92672">]&lt;/span> actors: placement order received: unlock
...
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>运行 MyActorClient&lt;/p>
&lt;p>如果MyActorClient成功的调用了MyActorService中的actor，它将会在控制台进行输出。&lt;/p>
&lt;blockquote>
&lt;p>如果你指定了不同的Dapr运行时http端口（默认端口：3500），你需要在运行客户端之前设置DAPR_HTTP_PORT环境变量。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash"> Success
PropertyA: ValueA, PropertyB: ValueB
&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;/li>
&lt;/ol></description></item></channel></rss>