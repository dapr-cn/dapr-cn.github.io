<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dapr 中文文档 – Actors</title><link>https://dapr-cn.github.io/developing-applications/building-blocks/actors/</link><description>Recent content in Actors on Dapr 中文文档</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dapr-cn.github.io/developing-applications/building-blocks/actors/index.xml" rel="self" type="application/rss+xml"/><item><title>Developing-Applications: Dapr Actors 概述</title><link>https://dapr-cn.github.io/developing-applications/building-blocks/actors/actors-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dapr-cn.github.io/developing-applications/building-blocks/actors/actors-overview/</guid><description>
&lt;p>Dapr Actors 运行时通过以下功能为 &lt;a href="https://dapr-cn.github.io/developing-applications/building-blocks/actors/actors-background/">virtual actors&lt;/a> 提供支持:&lt;/p>
&lt;h2 id="调用-actor-方法">调用 Actor 方法&lt;/h2>
&lt;p>您可以通过 HTTP/gRPC 来与 Dapr 交互以调用 actor 方法&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">POST/GET/PUT/DELETE http://localhost:3500/v1.0/actors/&amp;lt;actorType&amp;gt;/&amp;lt;actorId&amp;gt;/method/&amp;lt;method&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>您可以在请求主体中为 actor 方法提供任何数据，并且请求的响应在响应主体中，这是来自 actor 方法调用的数据。&lt;/p>
&lt;p>参阅&lt;a href="https://dapr-cn.github.io/reference/api/actors_api/#invoke-actor-method">api spec&lt;/a> 获取更多信息。&lt;/p>
&lt;h2 id="actor-状态管理">Actor 状态管理&lt;/h2>
&lt;p>Actor 可以使用状态管理功能可靠地保存状态。&lt;/p>
&lt;p>您可以通过 HTTP/GRPC 端点与 Dapr 进行状态管理。&lt;/p>
&lt;p>要使用Actor，您的状态存储必须支持多项目事务。 这意味着您的状态存储 &lt;a href="https://github.com/dapr/components-contrib/tree/master/state">组件&lt;/a> 必须实现 &lt;a href="https://github.com/dapr/components-contrib/blob/master/state/transactional_store.go">TransactionalStore&lt;/a> 接口。 以下状态存储实现了此接口:&lt;/p>
&lt;ul>
&lt;li>Redis&lt;/li>
&lt;li>MongoDB&lt;/li>
&lt;li>PostgreSQL&lt;/li>
&lt;li>SQL Server&lt;/li>
&lt;li>Azure CosmSDB&lt;/li>
&lt;/ul>
&lt;h2 id="actor-timers-和-reminders">Actor timers 和 reminders&lt;/h2>
&lt;p>Actors 可以通过 timer 或者 remider 自行注册周期性的任务.&lt;/p>
&lt;h3 id="actor-timers">Actor timers&lt;/h3>
&lt;p>你可以通过 timer 在actor中注册一个回调。&lt;/p>
&lt;p>Dapr Actor 运行时确保回调方法被顺序调用，而非并发调用。这意味着，在此回调完成执行之前，不会有其他Actor方法或timer/remider回调被执行。&lt;/p>
&lt;p>Timer的下一个周期在回调完成执行后开始计算。 这意味着timer在执行回调时停止，并在回调结束时开始。&lt;/p>
&lt;p>Dapr Actor 运行时在回调完成时保存对actor的状态所作的更改。 如果在保存状态时发生错误，那么将取消激活该actor对象，并且将激活新实例。&lt;/p>
&lt;p>当 actor 作为垃圾收集的一部分被停用时，所有 timer 都会停止。 在此之后，将不会再调用 timer 的回调。 此外， Dapr Actors 运行时不会保留有关在失活之前运行的 timer 的任何信息。 也就是说，重新启动 actor 后将会激活的 timer 完全取决于注册时登记的 timer。&lt;/p>
&lt;p>您可以通过将 HTTP/gRPC 请求调用 Dapr 来为 actor 创建 timer。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-http" data-lang="http">&lt;span style="color:#960050;background-color:#1e0010">POST/PUT http://localhost:3500/v1.0/actors/&amp;lt;actorType&amp;gt;/&amp;lt;actorId&amp;gt;/timers/&amp;lt;name&amp;gt;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Timer 的 &lt;code>duetime&lt;/code> 和回调函数可以在请求主体中指定。 到期时间（due time）表示注册后 timer 将首次触发的事件。 &lt;code>period&lt;/code> 表示 timer 在此之后触发的频率。 到期时间为0表示立即执行。 负 due times 和负 periods 都是无效。&lt;/p>
&lt;p>以下请求主体将配置一个 timer，该 timer 的 &lt;code>dueTime&lt;/code> 为 9 秒， &lt;code>period &lt;/code>为 3 秒。 这意味着它将在9秒后首次触发，然后每3秒触发一次。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;dueTime&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0h0m9s0ms&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;period&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0h0m3s0ms&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以下请求主体将配置一个 timer，该 timer 的 &lt;code>dueTime&lt;/code> 为 0 秒， &lt;code>period&lt;/code>为 3 秒。 这意味着它将在注册之后立即触发，然后每3秒触发一次。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;dueTime&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0h0m0s0ms&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;period&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0h0m3s0ms&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>您可以通过调用来除去 Actor timers&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-http" data-lang="http">&lt;span style="color:#960050;background-color:#1e0010">DELETE http://localhost:3500/v1.0/actors/&amp;lt;actorType&amp;gt;/&amp;lt;actorId&amp;gt;/timers/&amp;lt;name&amp;gt;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>参阅&lt;a href="https://dapr-cn.github.io/reference/api/actors_api/#invoke-timer">api spec&lt;/a> 获取更多信息。&lt;/p>
&lt;h3 id="actor-reminders">Actor reminders&lt;/h3>
&lt;p>Reminders 是一种机制，用于在指定时间触发 &lt;em>持久化&lt;/em>的回调。 它们的功能类似于 timer。 但与 timer 不同，在所有情况下 reminders 都会触发，直到 actor 显式取消注册 reminders 或删除 actor 。 具体而言， reminders 会在所有 actor 失活和故障时也会触发触发，因为Dapr Actors 运行时会将 reminders 信息持久化到 Dapr Actors 状态提供者中。&lt;/p>
&lt;p>您可以通过将 HTTP/gRPC 请求调用 Dapr 来为 actor 创建 reminders。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-http" data-lang="http">&lt;span style="color:#960050;background-color:#1e0010">POST/PUT http://localhost:3500/v1.0/actors/&amp;lt;actorType&amp;gt;/&amp;lt;actorId&amp;gt;/reminders/&amp;lt;name&amp;gt;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Reminders 的 &lt;code>duetime&lt;/code> 和回调函数可以在请求主体中指定。 到期时间（due time）表示注册后 reminders将首次触发的时间。 &lt;code>period&lt;/code> 表示 reminders 在此之后触发的频率。 到期时间为0表示立即执行。 负 due times 和负 periods 都是无效。 若要注册仅触发一次的 reminders ，请将 period 设置为空字符串。&lt;/p>
&lt;p>以下请求主体将配置一个 reminders，该 reminders 的 &lt;code>dueTime&lt;/code> 为 9 秒， &lt;code>period&lt;/code>为 3 秒。 这意味着它将在9秒后首次触发，然后每3秒触发一次。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;dueTime&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0h0m9s0ms&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;period&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0h0m3s0ms&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以下请求主体将配置一个 reminders，该 reminders 的 &lt;code>dueTime&lt;/code> 为 0 秒， &lt;code>period&lt;/code>为 3 秒。 这意味着它将在注册之后立即触发，然后每3秒触发一次。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;dueTime&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0h0m0s0ms&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;period&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0h0m3s0ms&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以下请求主体将配置一个 reminders，该 reminders 的 &lt;code>dueTime&lt;/code> 为 15 秒， &lt;code>period&lt;/code>为空。 这意味着它将在15秒后首次触发，之后就不再被触发。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;dueTime&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0h0m15s0ms&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;period&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="检索-actor-reminders">检索 actor reminders&lt;/h4>
&lt;p>您可以通过调用来检索 actor reminders&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-http" data-lang="http">&lt;span style="color:#960050;background-color:#1e0010">GET http://localhost:3500/v1.0/actors/&amp;lt;actorType&amp;gt;/&amp;lt;actorId&amp;gt;/reminders/&amp;lt;name&amp;gt;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="删除-actor-reminders">删除 actor reminders&lt;/h4>
&lt;p>您可以通过调用来除去 Actor timers&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-http" data-lang="http">&lt;span style="color:#960050;background-color:#1e0010">DELETE http://localhost:3500/v1.0/actors/&amp;lt;actorType&amp;gt;/&amp;lt;actorId&amp;gt;/reminders/&amp;lt;name&amp;gt;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请参阅 &lt;a href="https://dapr-cn.github.io/reference/api/actors_api/#invoke-reminder">Api 描述&lt;/a> 以获取更多详细信息。&lt;/p></description></item><item><title>Developing-Applications: Actors简介</title><link>https://dapr-cn.github.io/developing-applications/building-blocks/actors/actors-background/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dapr-cn.github.io/developing-applications/building-blocks/actors/actors-background/</guid><description>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Actor_model">actor 模式&lt;/a> 阐述了 &lt;strong>Actors&lt;/strong> 为最低级别的“计算单元”。 换句话说，您将代码写入独立单元 ( 称为actor) ，该单元接收消息并一次处理消息，而不进行任何类型的并行或线程处理。&lt;/p>
&lt;p>当您的代码处理消息时，它可以发送一个或多个消息给其他Actors，或创建新的Actors。 底层 &lt;strong>运行时&lt;/strong> 将管理每个 actor 的运行方式，时机和位置，并在 Actors 之间传递消息。&lt;/p>
&lt;p>大量 Actors 可以同时执行，而 Actors 可以相互独立执行。&lt;/p>
&lt;p>Dapr 包含专门实现 &lt;a href="https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/">virtual actors 模式&lt;/a> 的运行时。 通过 Dapr 的实现，您可以根据 Actors 模型编写 Dapr Actor，而 Dapr 利用底层平台提供的可扩展性和可靠性保证。&lt;/p>
&lt;h2 id="快速链接">快速链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://dapr-cn.github.io/developing-applications/building-blocks/actors/actors-overview/">Dapr Actor 特性&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dapr-cn.github.io/reference/api/actors_api/">Dapr Actor API 规范&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="何时使用-actors">何时使用 Actors？&lt;/h3>
&lt;p>与任何其他技术决策一样，您应该根据您尝试解决的问题来决定是否使用 Actors。&lt;/p>
&lt;p>Actor 设计模式可以很好适应一些分布式系统问题和场景，但您首先应该考虑的是模式的约束。 一般来说，在下列情况下，考虑 actor 模式来模拟你的问题或场景：&lt;/p>
&lt;ul>
&lt;li>您的问题空间涉及大量(数千或更多) 的独立和孤立的小单位和逻辑。&lt;/li>
&lt;li>您想要处理单线程对象，这些对象不需要外部组件的大量交互，例如在一组 Actors 之间查询状态。&lt;/li>
&lt;li>您的 actor 实例不会通过发出I/O操作来阻塞调用方。&lt;/li>
&lt;/ul>
&lt;h2 id="dapr-中的-actors">Dapr 中的 Actors&lt;/h2>
&lt;p>每个 actor 都被定义为一个 actor 类型的实例，这对象作为一与一个个类实例的方式相同。 例如，可能存在实现计算器功能的 actor 类型，并且该类型的许多 Actors 分布在集群的各个节点上。 每个这样的 actor 都是由一个 actor ID 确定的。&lt;/p>
&lt;img src="https://dapr-cn.github.io/images/actor_background_game_example.png" width=400>
&lt;h2 id="actor-生命周期">Actor 生命周期&lt;/h2>
&lt;p>Dapr Actors 是虚拟的，这意味着他们的生命周期与他们的内存状况无关。 因此，它们不需要显式创建或销毁。 Dapr Actors 运行时在第一次接收到该 actor ID 的请求时自动激活 actor。 如果 actor 在一段时间内未被使用，那么 Dapr Actors 运行时将回收内存对象。 如果以后需要重新启动，它还将保持对 actor 的一切原有数据。&lt;/p>
&lt;p>调用 actor 方法和 reminders 都会重置 actor 的空闲时长计时器，例如， reminders 的触发将使 actor 保持活动状态。 不论 actor 是否处于活动状态或不活动状态 Actor reminders 都会触发，对不活动 actor ，那么会首先激活 actor。 Actor timers 不会重置空闲时间，因此 timer 触发不会使参与者保持活动状态。 Timer 仅在 actor 活跃时被触发。&lt;/p>
&lt;p>Dapr 运行时中的“空闲超时”和&amp;quot;扫描时间间隔&amp;quot;用于查看是否可以对 actor 进行垃圾收集。 当 Dapr 运行时调用 actor 服务以获取受支持的 actor 类型时，可以传递此信息。&lt;/p>
&lt;p>Virtual actors 生命周期抽象会将一些警告作为 virtual actors 模型的结果，而事实上， Dapr Actors 实施有时会偏离此模型。&lt;/p>
&lt;p>在第一次将消息发送到其 actor ID 时，将自动激活 actor ( 这将构造 actor 对象) 。 在一段时间后，actor 对象将被垃圾回收。 以后，再次使用 actor ID 访问，将构造新的 actor。 Actor 的状态比对象的生命周期更久，因为状态存储在 Dapr 运行时的配置状态提供程序中（也就是说Actor即使不在活跃状态，仍然可以读取它的状态）。&lt;/p>
&lt;h2 id="分发和故障转移">分发和故障转移&lt;/h2>
&lt;p>为了提供可扩展性和可靠性，Actors 实例分布在整个集群中， Dapr 会根据需要自动将对象从失败的节点迁移到健康的节点。&lt;/p>
&lt;p>Actors 分布在 Actors 服务的实例中，并且这些实例分布在集群中的节点之间。 每个服务实例都包含给定 Actors 类型的一组 Actors。&lt;/p>
&lt;h3 id="actor-安置服务-actor-placement-service">Actor 安置服务 (Actor placement service)&lt;/h3>
&lt;p>Dapr actor 运行时为您管理分发方案和键范围设置。 这是由 actor &lt;code>Placement&lt;/code> 服务完成的。 创建服务的新实例时，相应的 Dapr 运行时将注册它可以创建的 actor 类型， &lt;code>Placement&lt;/code> 服务将计算给定 actor 类型的所有实例之间的分区。 每个 actor 类型的分区信息表将更新并存储在环境中运行的每个 Dapr 实例中，并且可以随着新 actor 服务实例创建和销毁动态更改。 如下图所示。&lt;/p>
&lt;img src="https://dapr-cn.github.io/images/actors_background_placement_service_registration.png" width=600>
&lt;p>当客户端调用具有特定 Id 的 actor ( 例如，actor Id123) 时，客户端的 Dapr 实例将哈希 actor 类型和 Id，并使用该信息来调用相应的 Dapr 实例，该实例可以为该特定 actor Id 提供实例以接收请求。 因此，始终对任何给定 actor Id 始终会落在同一分区 (或服务实例) 。 如下图所示。&lt;/p>
&lt;img src="https://dapr-cn.github.io/images/actors_background_id_hashing_calling.png" width=600>
&lt;p>这简化了一些选择，但也带有一些考虑：&lt;/p>
&lt;ul>
&lt;li>默认情况下，Actors 被随机放入分区中，从而形成均匀的分布。&lt;/li>
&lt;li>由于 Actors 是随机放置的，因此可知，执行操作始终需要网络通信，包括方法调用数据的序列化和去序列化，产生延迟和开销。&lt;/li>
&lt;/ul>
&lt;p>注意：Dapr actor Placement 服务仅用于 actor 放置，因此，如果您的服务不使用 Dapr Actors，就不需要。 Placement 服务可以在所有 &lt;a href="https://dapr-cn.github.io/operations/hosting/"> 托管环境中&lt;/a>&lt;/a> ，包括自托管和 Kubernetes。&lt;/p>
&lt;h2 id="actor-通信">Actor 通信&lt;/h2>
&lt;p>您可以通过 HTTP/gRPC 来与 Dapr 交互以调用 actor 方法.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">POST/GET/PUT/DELETE http://localhost:3500/v1.0/actors/&amp;lt;actorType&amp;gt;/&amp;lt;actorId&amp;gt;/&amp;lt;method/state/timers/reminders&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>您可以在请求主体中为 actor 方法提供任何数据，并且请求的响应在响应主体中，这是来自 actor 方法调用的数据。&lt;/p>
&lt;p>请参阅 &lt;a href="https://dapr-cn.github.io/developing-applications/building-blocks/actors/actors-overview/">Dapr Actor 功能部件&lt;/a> ，以获取更多详细信息。&lt;/p>
&lt;h3 id="并发concurrency">并发（Concurrency）&lt;/h3>
&lt;p>Dapr Actors 运行时提供了一个简单的基于回合的访问模型，用于访问 actor 方法。 这意味着任何时候都不能有一个以上的线程在一个 actor 对象的代码内活动。 基于回合的访问大大简化了并发系统，因为不需要同步数据访问机制。 这也意味着系统的设计必须考虑到每个 actor 实例的单线程访问性质。&lt;/p>
&lt;p>单个 actor 实例一次不能处理多个请求。 如果 actor 实例预期要处理并发请求，可能会导致吞吐量瓶颈。&lt;/p>
&lt;p>如果两个 Actors 之间同时向其中一个 Actors 发出外部请求，则 Actors 可能会相互死锁。 Dapr actor 运行时会自动分出 actor 调用，并向调用方引发异常以中断可能死锁的情况。&lt;/p>
&lt;img src="https://dapr-cn.github.io/images/actors_background_communication.png" width=600>
&lt;h3 id="基于回合的访问">基于回合的访问&lt;/h3>
&lt;p>一个回合包括执行 actor 方法以响应来自其他 Actors 或客户端的请求，或执行 timer/reminders 回调。 即使这些方法和回调是异步的，但 Dapr Actors 运行时并没有将它们交错（Interleave ，即并发调用它们）。 在允许新回合之前，必须完全结束之前的回合。 换句话说，在允许对方法或回调进行新调用之前，必须完全完成当前正在执行的 actor 方法或 timer/reminders 回调。 如果执行从方法或回调返回结果，并且方法或回调返回的任务已完成，则方法或回调将被视为已完成。 值得强调的是，即使在不同方法、timer和回调中，基于回合的并发也一样起作用。&lt;/p>
&lt;p>Dapr Actors 运行时通过在回合开始时获取每个 actor 的锁并在回合结束时释放锁来实现基于回合的调用。 因此，基于回合的并发性是按每个 actor 执行的，而不是跨 Actors 执行的。 Actor 方法和 timer/reminders 回调可以代表不同的 Actors 同时执行。&lt;/p>
&lt;p>下面的示例演示了上述概念。 现在有一个实现了两个异步方法（例如，方法 1 和方法 2）、timer 和 reminders 的 actor。 下图显示了执行这些方法的时间线的示例，并代表属于此 Actors 类型的两个 Actors ( ActorId1 和 ActorId2 ) 的回调。&lt;/p>
&lt;img src="https://dapr-cn.github.io/images/actors_background_concurrency.png" width=600></description></item></channel></rss>