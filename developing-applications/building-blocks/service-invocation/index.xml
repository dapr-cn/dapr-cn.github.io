<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dapr 中文文档 – Service invocation</title><link>https://dapr-cn.github.io/developing-applications/building-blocks/service-invocation/</link><description>Recent content in Service invocation on Dapr 中文文档</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dapr-cn.github.io/developing-applications/building-blocks/service-invocation/index.xml" rel="self" type="application/rss+xml"/><item><title>Developing-Applications: 服务调用概述</title><link>https://dapr-cn.github.io/developing-applications/building-blocks/service-invocation/service-invocation-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dapr-cn.github.io/developing-applications/building-blocks/service-invocation/service-invocation-overview/</guid><description>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>通过服务调用，应用程序可以使用 &lt;a href="https://grpc.io">gRPC&lt;/a> 或 &lt;a href="https://www.w3.org/Protocols/">HTTP&lt;/a> 这样的标准协议来发现并可靠地与其他应用程序通信。&lt;/p>
&lt;p>在许多具有多个需要相互通信的服务的环境中，开发者经常会问自己以下问题：&lt;/p>
&lt;ul>
&lt;li>我如何发现和调用不同服务上的方法？&lt;/li>
&lt;li>我如何安全地调用其他服务？&lt;/li>
&lt;li>我如何处理重试和瞬态错误？&lt;/li>
&lt;li>我如何使用分布式跟踪来查看调用图来诊断生产中的问题？&lt;/li>
&lt;/ul>
&lt;p>Dapr 允许您通过一个组合了反向代理与内置服务发现的端点来克服这些挑战，同时能够利用内置的分布式跟踪，度量，错误处理等能力。&lt;/p>
&lt;p>Dapr 采用一种边车（Sidecar）、去中心化的架构。 要使用 Dapr 来调用应用程序，请在任意 Dapr 实例上使用 &lt;code>invoke&lt;/code> 这个API。 Sidecar 编程模型鼓励每个应用程序与自己的 Dapr 实例对话。 Dapr 实例会相互发现并进行通信。&lt;/p>
&lt;h3 id="调用逻辑">调用逻辑&lt;/h3>
&lt;p>下图是 Dapr的服务调用如何工作的总览图&lt;/p>
&lt;img src="https://dapr-cn.github.io/images/service-invocation-overview.png" width=800 alt="Diagram showing the steps of service invocation">
&lt;ol>
&lt;li>
&lt;p>Service A makes an http/gRPC call targeting Service B. The call goes to the local Dapr sidecar.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Dapr discovers Service B&amp;rsquo;s location using the &lt;a href="https://github.com/dapr/components-contrib/tree/master/nameresolution">name resolution component&lt;/a> which is running on the given &lt;a href="https://dapr-cn.github.io/operations/hosting/">hosting platform&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Dapr forwards the message to Service B&amp;rsquo;s Dapr sidecar&lt;/p>
&lt;p>&lt;strong>Note&lt;/strong>: All calls between Dapr sidecars go over gRPC for performance. Only calls between services and Dapr sidecars can be either HTTP or gRPC&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Service B&amp;rsquo;s Dapr sidecar forwards the request to the specified endpoint (or method) on Service B. Service B then runs its business logic code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Service B sends a response to Service A. The response goes to Service B&amp;rsquo;s sidecar.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Dapr forwards the response to Service A&amp;rsquo;s Dapr sidecar.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Service A receives the response.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="features">Features&lt;/h2>
&lt;p>Service invocation provides several features to make it easy for you to call methods on remote applications.&lt;/p>
&lt;h3 id="service-invocation-api">Service invocation API&lt;/h3>
&lt;p>The API for Pservice invocation can be found in the &lt;a href="https://dapr-cn.github.io/reference/api/service_invocation_api/">spec repo&lt;/a>.&lt;/p>
&lt;h3 id="namespaces-scoping">Namespaces scoping&lt;/h3>
&lt;p>Service invocation supports calls across namespaces. On all supported hosting platforms, Dapr app IDs conform to a valid FQDN format that includes the target namespace.&lt;/p>
&lt;p>For example, the following string contains the app ID &lt;code>nodeapp&lt;/code> in addition to the namespace the app runs in &lt;code>production&lt;/code>.&lt;/p>
&lt;pre>&lt;code>localhost:3500/v1.0/invoke/nodeapp.production/method/neworder
&lt;/code>&lt;/pre>&lt;p>This is especially useful in cross namespace calls in a Kubernetes cluster. Watch this video for a demo on how to use namespaces with service invocation. &lt;iframe width="560" height="315" src="https://www.youtube.com/embed/LYYV_jouEuA?start=497" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen mark="crwd-mark">&lt;/iframe>&lt;/p>
&lt;h3 id="retries">Retries&lt;/h3>
&lt;p>Service invocation performs automatic retries with backoff time periods in the event of call failures and transient errors.&lt;/p>
&lt;p>Errors that cause retries are:&lt;/p>
&lt;ul>
&lt;li>Network errors including endpoint unavailability and refused connections&lt;/li>
&lt;li>Authentication errors due to a renewing certificate on the calling/callee Dapr sidecars&lt;/li>
&lt;/ul>
&lt;p>Per call retries are performed with a backoff interval of 1 second up to a threshold of 3 times. Connection establishment via gRPC to the target sidecar has a timeout of 5 seconds.&lt;/p>
&lt;h3 id="service-to-service-security">Service-to-service security&lt;/h3>
&lt;p>All calls between Dapr applications can be made secure with mutual (mTLS) authentication on hosted platforms, including automatic certificate rollover, via the Dapr Sentry service. The diagram below shows this for self hosted applications.&lt;/p>
&lt;p>For more information read the &lt;a href="https://dapr-cn.github.io/concepts/security-concept/#sidecar-to-sidecar-communication">service-to-service security&lt;/a> article.&lt;/p>
&lt;img src="https://dapr-cn.github.io/images/security-mTLS-sentry-selfhosted.png" width=800>
&lt;h3 id="service-access-security">Service access security&lt;/h3>
&lt;p>Applications can control which other applications are allowed to call them and what they are authorized to do via access policies. This enables you to restrict sensitive applications, that say have personnel information, from being accessed by unauthorized applications, and combined with service-to-service secure communication, provides for soft multi-tenancy deployments.&lt;/p>
&lt;p>For more information read the &lt;a href="https://dapr-cn.github.io/operations/configuration/invoke-allowlist/">access control allow lists for service invocation&lt;/a> article.&lt;/p>
&lt;h3 id="observability">Observability&lt;/h3>
&lt;p>By default, all calls between applications are traced and metrics are gathered to provide insights and diagnostics for applications, which is especially important in production scenarios.&lt;/p>
&lt;p>For more information read the &lt;a href="https://dapr-cn.github.io/concepts/observability-concept/">observability&lt;/a> article.&lt;/p>
&lt;h3 id="pluggable-service-discovery">Pluggable service discovery&lt;/h3>
&lt;p>Dapr can run on any &lt;a href="https://dapr-cn.github.io/operations/hosting/">hosting platform&lt;/a>. For the supported hosting platforms this means they have a &lt;a href="https://github.com/dapr/components-contrib/tree/master/nameresolution">name resolution component&lt;/a> developed for them that enables service discovery. For example, the Kubernetes name resolution component uses the Kubernetes DNS service to resolve the location of other applications running in the cluster.&lt;/p>
&lt;h2 id="example">Example&lt;/h2>
&lt;p>Following the above call sequence, suppose you have the applications as described in the &lt;a href="https://github.com/dapr/quickstarts/blob/master/hello-world/README.md">hello world quickstart&lt;/a>, where a python app invokes a node.js app. In such a scenario, the python app would be &amp;ldquo;Service A&amp;rdquo; , and a Node.js app would be &amp;ldquo;Service B&amp;rdquo;.&lt;/p>
&lt;p>The diagram below shows sequence 1-7 again on a local machine showing the API call:&lt;/p>
&lt;img src="https://dapr-cn.github.io/images/service-invocation-overview-example.png" width=800>
&lt;ol>
&lt;li>The Node.js app has a Dapr app ID of &lt;code>nodeapp&lt;/code>. The python app invokes the Node.js app&amp;rsquo;s &lt;code>neworder&lt;/code> method by POSTing &lt;code>http://localhost:3500/v1.0/invoke/nodeapp/method/neworder&lt;/code>, which first goes to the python app&amp;rsquo;s local Dapr sidecar.&lt;/li>
&lt;li>Dapr discovers the Node.js app&amp;rsquo;s location using name resolution component (in this case mDNS while self-hosted) which runs on your local machine.&lt;/li>
&lt;li>Dapr forwards the request to the Node.js app&amp;rsquo;s sidecar using the location it just received.&lt;/li>
&lt;li>The Node.js app&amp;rsquo;s sidecar forwards the request to the Node.js app. The Node.js app performs its business logic, logging the incoming message and then persist the order ID into Redis (not shown in the diagram)&lt;/li>
&lt;li>The Node.js app sends a response to the Python app through the Node.js sidecar.&lt;/li>
&lt;li>Dapr forwards the response to the Python Dapr sidecar&lt;/li>
&lt;li>The Python app receives the resposne.&lt;/li>
&lt;/ol>
&lt;h2 id="next-steps">Next steps&lt;/h2>
&lt;ul>
&lt;li>Follow these guide on:
&lt;ul>
&lt;li>&lt;a href="https://dapr-cn.github.io/developing-applications/building-blocks/service-invocation/howto-invoke-discover-services/">How-to: Get started with HTTP service invocation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dapr-cn.github.io/operations/configuration/grpc/">How-to: Get started with Dapr and gRPC&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Try out the &lt;a href="https://github.com/dapr/quickstarts/blob/master/hello-world/README.md">hello world quickstart&lt;/a> which shows how to use HTTP service invocation or visit the samples in each of the &lt;a href="https://dapr-cn.github.io/developing-applications/sdks/">Dapr SDKs&lt;/a>&lt;/li>
&lt;li>Read the &lt;a href="https://dapr-cn.github.io/reference/api/service_invocation_api/">service invocation API specification&lt;/a>&lt;/li>
&lt;li>See the &lt;a href="https://dapr-cn.github.io/operations/performance-and-scalability/perf-service-invocation/">service invocation performance&lt;/a> numbers&lt;/li>
&lt;/ul></description></item><item><title>Developing-Applications: 入门指南：发现并调用服务</title><link>https://dapr-cn.github.io/developing-applications/building-blocks/service-invocation/howto-invoke-discover-services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dapr-cn.github.io/developing-applications/building-blocks/service-invocation/howto-invoke-discover-services/</guid><description>
&lt;p>本文介绍如何使用唯一的应用程序 ID 部署每个服务，以便其他服务可以使用服务调用 API 发现和调用这些终结点。&lt;/p>
&lt;h2 id="步骤-1-为服务选择标识">步骤 1: 为服务选择标识&lt;/h2>
&lt;p>Dapr 允许您为您的应用分配一个全局唯一ID。 此 ID 为您的应用程序封装了状态，不管它可能有多少实例。&lt;/p>
&lt;ul class="nav nav-tabs" id="tabs-0" role="tablist">&lt;li class="nav-item">&lt;a class="nav-link active"
id="tabs-0-self-hosted-cli-tab" data-toggle="tab" href="#tabs-0-self-hosted-cli" role="tab"
aria-controls="tabs-0-self-hosted-cli" aria-selected="true">
Self-Hosted (CLI)
&lt;/a>
&lt;/li>&lt;li class="nav-item">&lt;a class="nav-link"
id="tabs-0-kubernetes-tab" data-toggle="tab" href="#tabs-0-kubernetes" role="tab"
aria-controls="tabs-0-kubernetes" aria-selected="false">
Kubernetes
&lt;/a>
&lt;/li>&lt;/ul>
&lt;div class="tab-content" id="tabs-0-content">
&lt;div class="tab-pane fade show active" id="tabs-0-self-hosted-cli" role="tabpanel" aria-labelled-by="tabs-0-self-hosted-cli-tab">
&lt;br />&lt;p>在自托管方式下，设置 &lt;code>--app-id&lt;/code> 标记:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">dapr run --app-id cart --app-port &lt;span style="color:#ae81ff">5000&lt;/span> python app.py
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果您的应用使用 SSL 连接，您可以告诉Dapr 在不安全的 SSL 连接中调用您的应用：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">dapr run --app-id cart --app-port &lt;span style="color:#ae81ff">5000&lt;/span> --app-ssl python app.py
&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;div class="tab-pane fade" id="tabs-0-kubernetes" role="tabpanel" aria-labelled-by="tabs-0-kubernetes-tab">
&lt;br />&lt;h3 id="使用-kubernetes-设置标识">使用 Kubernetes 设置标识&lt;/h3>
&lt;p>在 Kubernetes 中，在您的pod 上设置 &lt;code>dapr.io/app-id&lt;/code> 注解：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">apps/v1&lt;/span>
&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Deployment&lt;/span>
&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">python-app&lt;/span>
&lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;span style="color:#f92672">labels&lt;/span>:
&lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">python-app&lt;/span>
&lt;span style="color:#f92672">spec&lt;/span>:
&lt;span style="color:#f92672">replicas&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#f92672">selector&lt;/span>:
&lt;span style="color:#f92672">matchLabels&lt;/span>:
&lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">python-app&lt;/span>
&lt;span style="color:#f92672">template&lt;/span>:
&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;span style="color:#f92672">labels&lt;/span>:
&lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">python-app&lt;/span>
&lt;span style="color:#f92672">annotations&lt;/span>:
&lt;span style="color:#f92672">dapr.io/enabled&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>
&lt;span style="color:#f92672">dapr.io/app-id&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cart&amp;#34;&lt;/span>
&lt;span style="color:#f92672">dapr.io/app-port&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;5000&amp;#34;&lt;/span>
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>如果应用程序使用 SSL 连接，那么可以使用 &lt;code>app-ssl: &amp;quot;true&amp;quot;&lt;/code> 注解 (完整列表 &lt;a href="https://dapr-cn.github.io/operations/hosting/kubernetes/kubernetes-annotations/">此处&lt;/a>) 告知 Dapr 在不安全的 SSL 连接上调用应用程序。&lt;/em>&lt;/p>
&lt;/div>
&lt;/div>
&lt;h2 id="步骤-2-设置服务">步骤 2: 设置服务&lt;/h2>
&lt;p>以下是购物车应用的 Python 示例。 它可以用任何编程语言编写。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">from&lt;/span> flask &lt;span style="color:#f92672">import&lt;/span> Flask
app &lt;span style="color:#f92672">=&lt;/span> Flask(__name__)
&lt;span style="color:#a6e22e">@app.route&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/add&amp;#39;&lt;/span>, methods&lt;span style="color:#f92672">=&lt;/span>[&lt;span style="color:#e6db74">&amp;#39;POST&amp;#39;&lt;/span>])
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>():
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Added!&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>:
app&lt;span style="color:#f92672">.&lt;/span>run()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此 Python 应用程序通过 &lt;code>/add()&lt;/code> 端点暴露了一个 &lt;code>add()&lt;/code> 方法。&lt;/p>
&lt;h2 id="步骤-3-调用服务">步骤 3: 调用服务&lt;/h2>
&lt;p>Dapr 采用边车（sidecar）、去中心化的架构。 要使用 Dapr 调用应用程序，您可以在任意 Dapr 实例中使用 &lt;code>调用&lt;/code> API。&lt;/p>
&lt;p>sidecar 编程模型鼓励每个应用程序与自己的 Dapr 实例对话。 Dapr 实例会相互发现并进行通信。&lt;/p>
&lt;ul class="nav nav-tabs" id="tabs-1" role="tablist">&lt;li class="nav-item">&lt;a class="nav-link active"
id="tabs-1-curl-tab" data-toggle="tab" href="#tabs-1-curl" role="tab"
aria-controls="tabs-1-curl" aria-selected="true">
curl
&lt;/a>
&lt;/li>&lt;li class="nav-item">&lt;a class="nav-link"
id="tabs-1-cli-tab" data-toggle="tab" href="#tabs-1-cli" role="tab"
aria-controls="tabs-1-cli" aria-selected="false">
CLI
&lt;/a>
&lt;/li>&lt;/ul>
&lt;div class="tab-content" id="tabs-1-content">
&lt;div class="tab-pane fade show active" id="tabs-1-curl" role="tabpanel" aria-labelled-by="tabs-1-curl-tab">
&lt;br />&lt;p>从一个终端或命令提示运行：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl http://localhost:3500/v1.0/invoke/cart/method/add -X POST
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于 add 端点是一个“POST”方法，我们在 curl 命令中使用了 &lt;code>-X POST&lt;/code>。&lt;/p>
&lt;p>要调用 &amp;ldquo;GET&amp;rdquo; 端点:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl http://localhost:3500/v1.0/invoke/cart/method/add
&lt;/code>&lt;/pre>&lt;/div>&lt;p>要调用 &amp;ldquo;DELETE&amp;rdquo; 端点:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl http://localhost:3500/v1.0/invoke/cart/method/add -X DELETE
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Dapr 将调用的服务返回的任何有效负载放在 HTTP 响应的消息体中。&lt;/p>
&lt;/div>
&lt;div class="tab-pane fade" id="tabs-1-cli" role="tabpanel" aria-labelled-by="tabs-1-cli-tab">
&lt;br />&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">dapr invoke --app-id cart --method add
&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/div>
&lt;h3 id="命名空间">命名空间&lt;/h3>
&lt;p>当运行于&lt;a href="https://dapr-cn.github.io/reference/api/service_invocation_api/#namespace-supported-platforms">支持命名空间&lt;/a>的平台时，在您的 app ID 中包含命名空间：&lt;code>myApp.production&lt;/code>&lt;/p>
&lt;p>例如，调用包含名称空间的示例 python 服务:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl http://localhost:3500/v1.0/invoke/cart.production/method/add -X POST
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看更多有关名称空间的内容，请参阅[跨命名空间 API 规范](https://dapr-cn.github.io/reference/api/service_invocation_api/#cross-namespace-invocation)。&lt;/p>
&lt;h2 id="步骤-4-查看跟踪和日志">步骤 4: 查看跟踪和日志&lt;/h2>
&lt;p>上面的示例显示了如何直接调用本地或 Kubernetes 中运行的其他服务。 Dapr 输出指标、跟踪和日志记录信息，允许您可视化服务之间的调用图、日志错误和可选地记录有效负载正文。&lt;/p>
&lt;p>有关跟踪和日志的更多信息，请参阅 &lt;a href="https://dapr-cn.github.io/concepts/observability-concept/">可观察性&lt;/a> 篇文章。&lt;/p>
&lt;p>相关链接&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dapr-cn.github.io/developing-applications/building-blocks/service-invocation/service-invocation-overview/">服务调用概述&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dapr-cn.github.io/reference/api/service_invocation_api/">服务调用 API 规范&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>